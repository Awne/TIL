# 클래스
> 클래스는 객체를 표현하기 위해 사용합니다.

# 생성자 함수
> 인스턴스를 생성하면 호출되는 함수입니다.
1. `생성자 함수`의 이름은 `__init__`입니다.
2. `클래스` 내 속성을 추가할 때 `생성자 함수` 내에서 선언해줍니다.
> 속성 이름 앞에 `__`를 붙이면 외부에서 접근할 수 없는 속성이 됩니다.

# 속성
1. 클래스의 속성에는 `클래스 속성`과 `인스턴스 속성`이 존재합니다.
2. `클래스 속성`은 `인스턴스`를 생성하지 않아도 존재하는 속성이고, `인스턴스` 속성은 `인스턴스`를 생성해야 함께 생성되는 속성입니다.
3. `생성자 함수`는 `인스턴스` 생성시 호출되므로 `생성자 함수`에서 생성되는 속성은 `인스턴스 속성`이 됩니다.
4. `클래스 속성`은 `생성자 함수` 외부에서 일반 변수처럼 선언합니다.
5. 클래스 속성에 접근하는 방법은 `클래스명.속성명`으로 접근합니다. 
# 메서드
1. `메서드`의 첫번째 인자는 항상 `self`입니다.
## 정적 메서드
2. `정적 메서드`는 `인스턴스`를 생성하지 않아도 클래스에서 바로 호출이 가능한 메서드이고 `@staticmethod` 데코레이터를 사용하여 정의합니다.
3. `정적 메서드`의 특징은 `self` 매개변수가 없다는 것입니다. 그래서 `인스턴스 속성`이나 `메서드`는 사용 할 수 없습니다.
## 클래스 메서드
1. `클래스 메서드`도 `인스턴스`의 호출없이 사용할 수 있습니다.
2. `클래스 속성`이나 다른 `메서드`에 접근할 때 사용하며 인자로 `cls`를 가진다.
3. `@classmethod` 데코레이터 사용.

# 상속
> 클래스 선언 시 괄호안에 `부모 클래스`를 추가한다.

> `상속`은 동등한 관계(is a)일때 사용함 : `Student is a Person`
> 
> 포함관계(has a)는 리스트를 만들어서 사용함 : `StudentList has a Student`

1. `자식 클래스`로 인스턴스를 생성하는 경우 `부모 클래스`의 생성자 함수는 호출된 적이 없기 때문에 부모 클래스의 멤버들을 사용할 수 없다.
2. 이때 필요한 개념이 `super`입니다. `자식 클래스`에서 `부모 클래스`의 `생성자 함수`를 호출하기 위해 `super().__init__`을 사용한다. 즉, `super()`은 부모 클래스를 반환한다고 할 수 있다.
> 만약 `자식 클래스`의 `생성자 함수`가 존재하지 않는다면 `부모 클래스`의 `생성자 함수`가 자동으로 호출됨.
3. `부모 클래스`의 메서드와 `자식 클래스`의 메서드의 이름이 같은 경우를 `메서드 오버라이딩`이라고 합니다.
> `메서드 오버라이딩`을 이용하면 각 인스턴스마다 메서드의 행동을 달리할 수 있고, `super`를 이용하여 메서드에 기능을 추가할 수도 있습니다.

# 추상 클래스
> `추상 클래스`는 `부모 클래스`로 사용되며 `자식 클래스`에서 사용할 멤버들의 목록만을 가집니다. 이 때 멤버들의 내용은 `pass`를 이용해 비워둡니다.
1. `추상 클래스`에서는 멤버들의 존재 자체만 정의하고 실제 구현은 `자식 클래스`에서 합니다.
2. `from abc import *`를 사용하여 모듈을 불러오고, `클래스`가 `추상 클래스`라는 것을 인식시키기 위해 `metaclass=ABCMeta`를 상속받습니다.
3. `추상 클래스`의 메서드는 `@abstractmethod` 데코레이터를 이용해 생성하고, 내용은 `pass`입니다.
> `추상 클래스`의 특징은 `자식 클래스`가 메서드를 구현하지 않으면 에러를 발생시키며, `추상 클래스`로 `인스턴스`를 생성할 수 없습니다.